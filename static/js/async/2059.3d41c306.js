"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([["2059"],{18170:function(e,n,i){i.r(n),i.d(n,{default:()=>c});var s=i(31549),l=i(6603);function p(e){let n=Object.assign({h1:"h1",a:"a",div:"div",ol:"ol",li:"li",code:"code",h2:"h2",p:"p",h3:"h3",ul:"ul",h4:"h4",pre:"pre"},(0,l.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"pipeline-设计",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#pipeline-设计",children:"#"}),"pipeline 设计"]}),"\n",(0,s.jsxs)(n.div,{className:"rspress-directive info",children:[(0,s.jsx)(n.div,{className:"rspress-directive-title",children:"Why Pipeline?"}),(0,s.jsx)(n.div,{className:"rspress-directive-content",children:(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"团队内前辈们的选择"}),"\n",(0,s.jsxs)(n.li,{children:["Pipeline的优势, 可以让",(0,s.jsx)(n.code,{children:"VSeed"}),"独立控制每一个图表类型的执行流程, 通过良好的设计, 让每个图表类型的实现解耦的同时又可以局部复用, 每一类图表类型都可以对任何细节的进行完美掌控, 这是 Pipeline 带来的, 也是",(0,s.jsx)(n.code,{children:"VSeed"}),"最需要的."]}),"\n",(0,s.jsxs)(n.li,{children:["与之比起来, Pipeline模式的缺点都是可以在设计时避免的, 只要在设计",(0,s.jsx)(n.code,{children:"Pipe"}),"时, 降低单个",(0,s.jsx)(n.code,{children:"Pipe"}),"的规模, 减少",(0,s.jsx)(n.code,{children:"Pipe"}),"之间的依赖, 就可以极大的避免这套模式带来的缺点"]}),"\n",(0,s.jsx)(n.li,{children:"经过四代的Pipeline的设计与优化, 到VSeed这里已经是第五个版本, 该踩的坑已经踩过了."}),"\n"]})})]}),"\n",(0,s.jsxs)(n.h2,{id:"什么是-pipeline",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#什么是-pipeline",children:"#"}),"什么是 Pipeline？"]}),"\n",(0,s.jsx)(n.p,{children:"Pipeline 是一种强大的抽象和工程实践， 旨在将一项复杂任务分解为一系列相互连接、按顺序执行的较小步骤， 其设计理念和实现方式深受函数式编程（FP）核心思想的深刻影响。"}),"\n",(0,s.jsxs)(n.h3,{id:"pipeline-的优势",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#pipeline-的优势",children:"#"}),"Pipeline 的优势:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"模块化： 原子化实现， 通过组合原子得到模块"}),"\n",(0,s.jsx)(n.li,{children:"自动化： 只需确定输入， 即可自动得到输出， 而无需关注内部实现。"}),"\n",(0,s.jsx)(n.li,{children:"纯函数： 指定输入， 一定得到预期输出， 是纯函数的特征。"}),"\n",(0,s.jsx)(n.li,{children:"并行性： 天然支持并发。"}),"\n",(0,s.jsx)(n.li,{children:"可重用性： 每一个模块， 均可复用。"}),"\n",(0,s.jsx)(n.li,{children:"可测试性： 理论上, 每个模块都是独立的， 可以单独测试， 确保质量。"}),"\n",(0,s.jsx)(n.li,{children:"可追踪性： 每个阶段的输入输出清晰，便于定位问题和监控流程状态。"}),"\n",(0,s.jsxs)(n.li,{children:["可缓存性： 理论上, 可以单独缓存单个",(0,s.jsx)(n.code,{children:"Pipe"}),"的输出, 所以可以避免重复计算， 提高效率。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"pipeline-的缺点",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#pipeline-的缺点",children:"#"}),"Pipeline 的缺点:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"先后依赖： 当Pipe之间存在先后依赖时, 会使得理解成本增加, 因为你需要先理解前面的阶段， 才能理解后面的阶段。需要对整体流程有较深入的理解， 才能快速定位问题。"}),"\n",(0,s.jsx)(n.li,{children:"调试成本： 由于 Pipeline 是按顺序执行的， 一旦某个阶段失败， 就会导致整个 Pipeline 失败。 这使得调试变得困难， 因为你需要定位失败的阶段， 并修复它。"}),"\n",(0,s.jsx)(n.li,{children:"性能问题： 由于 Pipeline 是按顺序执行的， 每个阶段的输出都需要等待前一个阶段完成， 这会导致性能问题。 特别是当某个阶段的执行时间较长时， 会影响整个 Pipeline 的执行效率。"}),"\n",(0,s.jsx)(n.li,{children:"函数式编程：  要理解全新的概念, 有一定的学习成本. 也是因此, 设计原理和实现细节需要写在贡献指南里, 方便其他开发者理解和使用, 弥补劣势."}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"vseed内应该如何编写pipeline",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#vseed内应该如何编写pipeline",children:"#"}),"VSeed内应该如何编写Pipeline?"]}),"\n",(0,s.jsxs)(n.h3,{id:"pipe-组合模式",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#pipe-组合模式",children:"#"}),"Pipe 组合模式"]}),"\n",(0,s.jsx)(n.p,{children:"多个功能Pipe, 可以组合成一个更大的功能Pipe, 也可以组合成一个更复杂的Pipeline."}),"\n",(0,s.jsx)(n.p,{children:"在VSeed中, 一个完整的Pipeline, 对应着一个图表类型的实现；通过描述Pipe的组合关系, 就能做出不同的图表类型. 在Pipeline组合阶段, 无需关注每个pipe的具体实现."}),"\n",(0,s.jsxs)(n.h4,{id:"组合差异",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#组合差异",children:"#"}),"组合差异"]}),"\n",(0,s.jsx)(n.p,{children:"举个例子:"}),"\n",(0,s.jsx)(n.p,{children:"折线图和面积图有大量功能可以复用, 例如标签、图例、坐标轴等, 但折线图没有面图元样式, 因此pipeline就通过组合功能Pipe, 解决上述差异, 整个过程中没有任何if语句."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const lineChartPipeline = [\n  label,\n  legend,\n  xAxis,\n  yAxis,\n  lineStyle,\n  pointStyle,\n]\n\nconst areaChartPipeline = [\n  label,\n  legend,\n  xAxis,\n  yAxis,\n  lineStyle,\n  pointStyle,\n\n  // 仅面积图有面图元样式\n  areaStyle,\n]\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"pipe-适配器模式",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#pipe-适配器模式",children:"#"}),"Pipe 适配器模式"]}),"\n",(0,s.jsx)(n.p,{children:"除了组合模式外, Pipe的构建往往有一定的条件, 为了满足不同条件下的Pipe组合, VSeed内大量使用了Pipe适配器"}),"\n",(0,s.jsxs)(n.h4,{id:"组合条件",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#组合条件",children:"#"}),"组合条件"]}),"\n",(0,s.jsx)(n.p,{children:"举个例子:"}),"\n",(0,s.jsx)(n.p,{children:"折线图有透视功能, 无透视时由VChart渲染, 输出VChart spec, 有透视时由VTable渲染, 输出VTable spec."}),"\n",(0,s.jsx)(n.p,{children:"透视折线图有基本上需要复用折线图的基本功能, 例如标签、图例、坐标轴等, 因此需要通过适配器模式, 将折线图的Pipe, 适配成透视折线图的Pipe."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const pivotLineChartPipeline = [\n  initPivotChart,\n  pivotIndicators([\n    label,\n    xAxis,\n    yAxis,\n    lineStyle,\n    pointStyle,\n  ]),\n  pivotChartLegend,\n] \n\nconst commonLineChartPipeline = [\n  label,\n  legend,\n  xAxis,\n  yAxis,\n  lineStyle,\n  pointStyle,\n]\n\nconst lineChartPipeline = [\n  pivotAdapter(commonLineChartPipeline, pivotLineChartPipeline)\n]\n"})}),"\n",(0,s.jsx)(n.p,{children:"综上, 每一个adapter就是一条if else, 可以将pipe内隐藏的条件, 抽象成一个adapter, 因此if else前置到了最顶层, 从而获得依赖关系更清晰的Pipeline, 减少维护成本."}),"\n",(0,s.jsxs)(n.h3,{id:"pipeline-的最基本单元-功能-pipe",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#pipeline-的最基本单元-功能-pipe",children:"#"}),"Pipeline 的最基本单元： 功能 Pipe"]}),"\n",(0,s.jsx)(n.p,{children:"VSeed期望所有的图表类型, 都以功能为最基本的单元， 提供足够的复用与扩展能力； 自底向上构建一个图表类型的 pipeline； 每个功能Pipe, 都应该是一个独立的、 可测试的、 可复用的模块；"}),"\n",(0,s.jsx)(n.p,{children:"其中最关键的是, 应该以功能差异抽象出不同的Pipe(即少写if else), 而非写一个大而全的Pipe."}),"\n",(0,s.jsxs)(n.h4,{id:"扁平化功能pipe",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#扁平化功能pipe",children:"#"}),"扁平化功能Pipe"]}),"\n",(0,s.jsx)(n.p,{children:"举个例子:"}),"\n",(0,s.jsx)(n.p,{children:"条形图、柱状图、折线图、面积图、散点图都有X轴与Y轴, 它们相似而又略有不同, 如果写一个大而全的 axes pipe, 可能会变成这样"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const lineChartPipeline = [\n  axes\n]\nconst barChartPipeline = [\n  axes\n]\nconst areaChartPipeline = [\n  axes\n]\nconst scatterChartPipeline = [\n  axes\n]\nconst axes = (spec, context) => {\n  if (isLine || isArea || isColumn){\n    // 折线图、面积图、柱状图有一个离散的轴, 一个连续的轴\n    return xy(spec, context) \n  }\n  if (isScatter){\n    // 散点图有2个连续的轴\n    return yy(spec, context) \n  }\n  if (isBar){\n    // 条形图有一个离散的轴, 一个连续的轴, 但与折线图、面积图、柱状图的轴方向不同\n    return yx(spec, context) \n  }\n}\n\nconst xy = (spec, context) => {\n  linearAxis(spec, context, {orient: 'left'})\n  bandAxis(spec, context, {orient: 'bottom'})\n}\n\nconst yx = (spec, context) => {\n  linearAxis(spec, context, {orient: 'bottom'})\n  bandAxis(spec, context, {orient: 'left'})\n}\n\nconst yy = (spec, context) => {\n  linearAxis(spec, context, {orient: 'bottom'})\n  linearAxis(spec, context, {orient: 'left'})\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"上述逻辑, 在一个功能Pipe内实现了根据图表类型, 选择不同的子功能pipe, 引发的问题是"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"xy、yx、yy内重复的功能又该如何复用? 大量的相似而又不同的子函数, 需要在不同的子功能pipe中, 被重复调用. 依赖关系容易变得错综复杂, 导致维护成本增加."}),"\n",(0,s.jsx)(n.li,{children:"修改折线图、面积图的功能, 容易遗漏条形图, 因为逻辑出现了分叉, 因此实现新功能时要考虑差异."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"当整个spec pipeline的规模扩大到几百个pipe时, 这样的编写逻辑会带来非常高昂的维护成本, 因此, 我们需要一种更简单的方式, 来实现根据图表类型, 选择不同的子功能pipe."}),"\n",(0,s.jsx)(n.p,{children:"继续上述的例子, 将差异抽象成不同的Pipe, 在更细粒度的功能上封装的差异, 最后在pipeline内直接组合, 就可以避免上述问题"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const lineChartPipeline = [\n  xBandAxis,\n  yLinearAxis,\n]\nconst barChartPipeline = [\n  yBandAxis,\n  xLinearAxis,\n]\nconst areaChartPipeline = [\n  xBandAxis,\n  yLinearAxis,\n]\nconst scatterChartPipeline = [\n  xLinearAxis,\n  yLinearAxis,\n]\n\nconst xBandAxis = (spec, context) => {\n}\nconst yBandAxis = (spec, context) => {\n}\nconst xLinearAxis = (spec, context) => {\n}\nconst yLinearAxis = (spec, context) => {\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"上述例子中, 没有实现axes pipe, 而是直接组合了xBandAxis、yBandAxis、xLinearAxis、yLinearAxis这4个pipe, 这样就避免了在axes pipe内根据图表类型, 选择不同的子功能pipe的问题, 从而避免了根据图表类型, 做出不同的判断, 从而减少了if else的使用."}),"\n",(0,s.jsx)(n.p,{children:"所以的图表类型差异的分叉, 应该是在Pipeline之上, 除非迫不得已, Pipeline内无需根据图表类型, 选择不同的子功能pipe."}),"\n",(0,s.jsx)(n.p,{children:"这样的组合方式, 符合VSeed的设计哲学, 即使用更扁平的功能Pipe的组合, 而不是if else条件判断做一个大而全的功能Pipe."})]})}function r(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(p,e)})):p(e)}let c=r;r.__RSPRESS_PAGE_META={},r.__RSPRESS_PAGE_META["zh-CN%2Fdevelopment%2FdesignPhilosophy%2Fpipeline%2FpipelineDesign.md"]={toc:[{id:"什么是-pipeline",text:"什么是 Pipeline？",depth:2},{id:"pipeline-的优势",text:"Pipeline 的优势:",depth:3},{id:"pipeline-的缺点",text:"Pipeline 的缺点:",depth:3},{id:"vseed内应该如何编写pipeline",text:"VSeed内应该如何编写Pipeline?",depth:2},{id:"pipe-组合模式",text:"Pipe 组合模式",depth:3},{id:"组合差异",text:"组合差异",depth:4},{id:"pipe-适配器模式",text:"Pipe 适配器模式",depth:3},{id:"组合条件",text:"组合条件",depth:4},{id:"pipeline-的最基本单元-功能-pipe",text:"Pipeline 的最基本单元： 功能 Pipe",depth:3},{id:"扁平化功能pipe",text:"扁平化功能Pipe",depth:4}],title:"pipeline 设计",headingTitle:"pipeline 设计",frontmatter:{}}}}]);
//# sourceMappingURL=2059.3d41c306.js.map