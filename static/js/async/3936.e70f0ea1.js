"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([["3936"],{61249:function(n,e,s){s.r(e),s.d(e,{default:()=>r});var a=s(31549),o=s(6603);function d(n){let e=Object.assign({h1:"h1",a:"a",div:"div",p:"p",h2:"h2",code:"code",h3:"h3",ol:"ol",li:"li",ul:"ul",pre:"pre"},(0,o.ah)(),n.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(e.h1,{id:"数据重塑-实现",children:[(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#数据重塑-实现",children:"#"}),"数据重塑-实现"]}),"\n",(0,a.jsxs)(e.div,{className:"rspress-directive info",children:[(0,a.jsx)(e.div,{className:"rspress-directive-title",children:"简单而又巧妙"}),(0,a.jsxs)(e.div,{className:"rspress-directive-content",children:[(0,a.jsx)(e.p,{children:"\n这是VSeed最有意思的, 也是最核心的模块, 看似复杂, 实则非常简单与巧妙, 仅仅不到200行代码."}),(0,a.jsx)(e.p,{children:"只要善用foldMeasures 与 unfoldDimensions, 可以将任意指标维度, 转换为固定的指标与维度, 做到足够自由的可视化映射."})]})]}),"\n",(0,a.jsxs)(e.h2,{id:"foldmeasures",children:[(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#foldmeasures",children:"#"}),"foldMeasures"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.a,{href:"https://github.com/VisActor/VSeed/blob/main/packages/vseed/src/dataReshape/foldMeasures.ts",rel:"noopener noreferrer",target:"_blank",children:"源代码位置"})}),"\n",(0,a.jsxs)(e.p,{children:["foldMeasures 将所有的指标 ",(0,a.jsx)(e.code,{children:"fold"})," 为一个指标, 增加一个",(0,a.jsx)(e.code,{children:"指标名称维度"}),"和一个",(0,a.jsx)(e.code,{children:"指标Id"}),"维度, 所有的可能丢失信息都存储在",(0,a.jsx)(e.code,{children:"foldInfo"}),"内, 并且在这个过程中可以进行数据统计"]}),"\n",(0,a.jsxs)(e.h3,{id:"特性",children:[(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#特性",children:"#"}),"特性"]}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"特性1: foldMeasures执行完之后, 一定只有1个指标字段, 即能够将多指标描述的数据, 都转换成1个指标; 将任意多指标数据对应一个图元"}),"\n",(0,a.jsx)(e.li,{children:"特性2: 1. 数据条目与图元（几何元素）的数据严格一致，一条数据对应一个图元"}),"\n",(0,a.jsx)(e.li,{children:"特性3: 该过程进行数据统计"}),"\n"]}),"\n",(0,a.jsxs)(e.div,{className:"rspress-directive tip",children:[(0,a.jsx)(e.div,{className:"rspress-directive-title",children:"最妙的地方!!!"}),(0,a.jsx)(e.div,{className:"rspress-directive-content",children:(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"1"}),"个指标",(0,a.jsx)(e.code,{children:"0"}),"个维度, foldMeasures 后可以获得",(0,a.jsx)(e.code,{children:"1"}),"个指标",(0,a.jsx)(e.code,{children:"2"}),"个维度(包括指标名称和指标Id)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"4"}),"个指标",(0,a.jsx)(e.code,{children:"1"}),"个维度, 经过",(0,a.jsx)(e.code,{children:"2"}),"次foldMeasures 后可以获得",(0,a.jsx)(e.code,{children:"2"}),"个指标",(0,a.jsx)(e.code,{children:"3"}),"个维度(包括指标名称和指标Id), 从而完美的可以支持双轴图等场景."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"N"}),"个指标",(0,a.jsx)(e.code,{children:"0"}),"个维度, 经过",(0,a.jsx)(e.code,{children:"Y"}),"(Y ≤ N)次foldMeasures 后, 可以获得",(0,a.jsx)(e.code,{children:"Y"}),"个指标和",(0,a.jsx)(e.code,{children:"2"}),"个维度(包括指标名称和指标Id)"]}),"\n"]})})]}),"\n",(0,a.jsxs)(e.h3,{id:"最小可运行示例",children:[(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#最小可运行示例",children:"#"}),"最小可运行示例"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",meta:"title=foldMeasures",children:"const data = [\n  { category: 'A', sales: 100, profit: 30 },\n  { category: 'B', sales: 200, profit: 50 },\n]\n\nconst measures = [\n  { id: 'sales', alias: 'Sales' },\n  { id: 'profit', alias: 'Profit' },\n]\n\nfunction foldMeasures(dataset, measures, options) {\n  const {\n    measureId,\n    measureName,\n    measureValue,\n    colorMeasureId,\n    allowEmptyFold = true,\n  } = options || {}\n\n  const foldInfo = {\n    measureId,\n    measureName,\n    measureValue,\n    statistics: {\n      max: -Infinity,\n      min: Infinity,\n      sum: 0,\n      count: 0,\n      colorMin: Infinity,\n      colorMax: -Infinity,\n    },\n    foldMap: {},\n  }\n\n  const ids = measures.map(m => m.id)\n  const result = []\n\n  for (const row of dataset) {\n    for (const measure of measures) {\n      const { id, alias } = measure\n      const newRow = { ...row }\n\n      // 删除其他指标字段，避免重复\n      for (const key of ids) {\n        delete newRow[key]\n      }\n\n      newRow[measureId] = id\n      newRow[measureName] = alias || id\n      newRow[measureValue] = row[id]\n\n      if (colorMeasureId) {\n        const colorValue = row[colorMeasureId]\n        newRow.color = colorValue\n        foldInfo.statistics.colorMin = Math.min(foldInfo.statistics.colorMin, Number(colorValue))\n        foldInfo.statistics.colorMax = Math.max(foldInfo.statistics.colorMax, Number(colorValue))\n      }\n\n      const val = Number(row[id])\n      foldInfo.statistics.min = Math.min(foldInfo.statistics.min, val)\n      foldInfo.statistics.max = Math.max(foldInfo.statistics.max, val)\n      foldInfo.statistics.sum += val\n      foldInfo.statistics.count++\n\n      foldInfo.foldMap[id] = alias\n\n      result.push(newRow)\n    }\n  }\n\n  return { dataset: result, foldInfo }\n}\n\nconst { dataset: foldedData, foldInfo } = foldMeasures(data, measures, {\n  measureId: '__MeaId__',\n  measureName: '__MeaName__',\n  measureValue: '__MeaValue__',\n})\n\nconsole.log(foldedData)\n"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-json",meta:"title=预期输出",children:'[\n  {\n    "category": "A",\n    "__MeaId__": "sales",\n    "__MeaName__": "Sales",\n    "__MeaValue__": 100\n  },\n  {\n    "category": "A",\n    "__MeaId__": "profit",\n    "__MeaName__": "Profit",\n    "__MeaValue__": 30\n  },\n  {\n    "category": "B",\n    "__MeaId__": "sales",\n    "__MeaName__": "Sales",\n    "__MeaValue__": 200\n  },\n  {\n    "category": "B",\n    "__MeaId__": "profit",\n    "__MeaName__": "Profit",\n    "__MeaValue__": 50\n  }\n]\n'})}),"\n",(0,a.jsxs)(e.h2,{id:"unfolddimensions",children:[(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#unfolddimensions",children:"#"}),"unfoldDimensions"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.a,{href:"https://github.com/VisActor/VSeed/blob/main/packages/vseed/src/dataReshape/unfoldDimensions.ts",rel:"noopener noreferrer",target:"_blank",children:"源代码位置"})}),"\n",(0,a.jsxs)(e.p,{children:["unfoldDimensions 在不丢失信息的前提下, 将任意的维度 ",(0,a.jsx)(e.code,{children:"concat"})," 为一个新的维度, 所有的增加的信息都存储在",(0,a.jsx)(e.code,{children:"unfoldInfo"}),"内."]}),"\n",(0,a.jsx)(e.p,{children:"一个完整unfoldDimensions == 所有维度值转指标 + 一次foldMeasures"}),"\n",(0,a.jsx)(e.p,{children:"但遍历dataset的开销是巨大的, 一次多余的 foldMeasures 会导致性能下降."}),"\n",(0,a.jsx)(e.p,{children:"foldMeasures 可以直接保证一条数据只有一个指标, 因此可以直接在源数据上进行单纯的合并, 就能巧妙的达到等价效果, 最终从而大幅度提升性能."}),"\n",(0,a.jsx)(e.p,{children:"经过思考, 理论上unfoldDimensions可以和foldMeasures完全合并, 在一次dataset 遍历中完成所有数据处理, 但为了可读性和可维护性, 在没有性能瓶颈的情况下, 暂定不合并."}),"\n",(0,a.jsxs)(e.h3,{id:"特性-1",children:[(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#特性-1",children:"#"}),"特性"]}),"\n",(0,a.jsx)(e.p,{children:"特性1: unfoldDimensions执行完之后, 一定只有1个指标字段,\n特性2: 可以在不丢失原数据的情况下, 合并维度"}),"\n",(0,a.jsxs)(e.div,{className:"rspress-directive tip",children:[(0,a.jsx)(e.div,{className:"rspress-directive-title",children:"最妙的地方!!!"}),(0,a.jsx)(e.div,{className:"rspress-directive-content",children:(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"只要在foldMeasures后进行, 就可以通过最简单的 concat 操作, 即可完成展开维度与合并指标, 性能极其优异."}),"\n",(0,a.jsx)(e.li,{children:"任意的维度都能合并为一个全新的维度字段, 做到任意的视觉通道映射."}),"\n",(0,a.jsxs)(e.li,{children:["因为本身并不复杂, 所以理论上可以和 ",(0,a.jsx)(e.code,{children:"foldMeasures"})," 合并在一起, 降低遍历次数, 提升性能."]}),"\n"]})})]}),"\n",(0,a.jsxs)(e.h3,{id:"最小可运行示例-1",children:[(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#最小可运行示例-1",children:"#"}),"最小可运行示例"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:'const XEncoding = \'__DimX__\'\nconst ColorEncoding = \'__DimColor__\'\n/**\n * 展开并合并视觉通道的维度, 在foldMeasures后合并维度, 所以不需要进行笛卡尔积\n * @param {Array<Object>} dataset 原始数据集\n * @param {Array<Object>} dimensions 维度数组，每个维度对象至少包含 id 字段\n * @param {Object} encoding 编码对象，key为通道名，value为维度id数组\n * @param {Object} options 配置项\n *  - foldMeasureId: 折叠指标的字段名\n *  - separator: 维度值拼接分隔符\n *  - colorItemAsId: 是否只用颜色项作为 colorId，默认 false\n * @returns {Object} { dataset, unfoldInfo }\n */\nfunction unfoldDimensions(dataset, dimensions, encoding, options) {\n  const { foldMeasureId, separator, colorItemAsId } = options || {}\n\n  const unfoldInfo = {\n    encodingX: XEncoding,\n    encodingColor: ColorEncoding,\n\n    colorItems: [],\n    colorIdMap: {},\n  }\n\n  // 根据 encoding 过滤对应维度\n  const xDimensions = encoding.x ? dimensions.filter(d => encoding.x.includes(d.id)) : []\n  const colorDimensions = encoding.color ? dimensions.filter(d => encoding.color.includes(d.id)) : []\n\n  const colorItemsSet = new Set()\n  const colorIdMap = {}\n\n  for (let i = 0; i < dataset.length; i++) {\n    const datum = dataset[i]\n\n    applyEncoding(XEncoding, xDimensions, datum, separator)\n    applyEncoding(ColorEncoding, colorDimensions, datum, separator)\n\n    const measureId = String(datum[foldMeasureId])\n    const colorItem = String(datum[ColorEncoding])\n    colorItemsSet.add(colorItem)\n  }\n\n  unfoldInfo.colorItems = Array.from(colorItemsSet)\n\n  return {\n    dataset,\n    unfoldInfo,\n  }\n}\n\n/**\n * 应用编码至数据中, 原地修改 datum\n * @param {string} encoding 编码字段名\n * @param {Array<Object>} dimensions 维度数组\n * @param {Object} datum 单条数据\n * @param {string} separator 拼接分隔符\n */\nfunction applyEncoding(encoding, dimensions, datum, separator) {\n  if (encoding && dimensions.length) {\n    datum[encoding] = dimensions.map(dim => String(datum[dim.id])).join(separator)\n  }\n}\n\n\nconst dataset = [\n  { "category": "A", "__MeaId__": "sales",  "__MeaName__":  "Sales",  "__MeaValue__": 100 },\n  { "category": "A", "__MeaId__": "profit", "__MeaName__": "Profit",  "__MeaValue__": 30  },\n  { "category": "B", "__MeaId__": "sales",  "__MeaName__":  "Sales",  "__MeaValue__": 200 },\n  { "category": "B", "__MeaId__": "profit", "__MeaName__": "Profit",  "__MeaValue__": 50  }\n]\nconst dimensions = [\n  { id: \'category\'},\n  { id: \'__MeaName__\'},\n]\n\nconst encoding = {\n  x: [\'category\'],\n  color: [\'__MeaName__\'],\n}\n\nconst options = {\n  foldMeasureId: \'__MeaId__\',\n  separator: \'-\',\n  colorItemAsId: false,\n}\n\nconst { dataset: unfoldedData, unfoldInfo } = unfoldDimensions(dataset, dimensions, encoding, options)\n\nconsole.log(unfoldedData)\n\n\n'})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-json",meta:"title=预期输出",children:'[\n  {\n    "category": "A",\n    "__MeaId__": "sales",\n    "__MeaName__": "Sales",\n    "__MeaValue__": 100,\n    "__DimX__": "A",\n    "__DimColor__": "Sales"\n  },\n  {\n    "category": "A",\n    "__MeaId__": "profit",\n    "__MeaName__": "Profit",\n    "__MeaValue__": 30,\n    "__DimX__": "A",\n    "__DimColor__": "Profit"\n  },\n  {\n    "category": "B",\n    "__MeaId__": "sales",\n    "__MeaName__": "Sales",\n    "__MeaValue__": 200,\n    "__DimX__": "B",\n    "__DimColor__": "Sales"\n  },\n  {\n    "category": "B",\n    "__MeaId__": "profit",\n    "__MeaName__": "Profit",\n    "__MeaValue__": 50,\n    "__DimX__": "B",\n    "__DimColor__": "Profit"\n  }\n]\n'})})]})}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,o.ah)(),n.components);return e?(0,a.jsx)(e,Object.assign({},n,{children:(0,a.jsx)(d,n)})):d(n)}let r=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["zh-CN%2Fdevelopment%2FdesignPhilosophy%2FdataReshape%2FdataReshapeImplementation.md"]={toc:[{id:"foldmeasures",text:"foldMeasures",depth:2},{id:"特性",text:"特性",depth:3},{id:"最小可运行示例",text:"最小可运行示例",depth:3},{id:"unfolddimensions",text:"unfoldDimensions",depth:2},{id:"特性-1",text:"特性",depth:3},{id:"最小可运行示例-1",text:"最小可运行示例",depth:3}],title:"数据重塑-实现",headingTitle:"数据重塑-实现",frontmatter:{}}}}]);
//# sourceMappingURL=3936.e70f0ea1.js.map